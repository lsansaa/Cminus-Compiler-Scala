
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Wed Dec 07 02:21:19 CLST 2016
//----------------------------------------------------

package Parser;

import java_cup.runtime.*;
import java.io.*;
import Ast.*;
import ic.lex.Lexer;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Wed Dec 07 02:21:19 CLST 2016
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\107\000\002\002\004\000\002\002\003\000\002\003" +
    "\004\000\002\003\003\000\002\004\003\000\002\004\003" +
    "\000\002\005\005\000\002\005\010\000\002\042\003\000" +
    "\002\042\003\000\002\006\010\000\002\007\003\000\002" +
    "\007\003\000\002\010\005\000\002\010\003\000\002\011" +
    "\004\000\002\011\006\000\002\012\006\000\002\013\004" +
    "\000\002\013\003\000\002\014\004\000\002\014\003\000" +
    "\002\015\003\000\002\015\003\000\002\015\003\000\002" +
    "\015\003\000\002\015\003\000\002\016\004\000\002\016" +
    "\003\000\002\017\007\000\002\017\011\000\002\020\003" +
    "\000\002\020\003\000\002\021\007\000\002\022\013\000" +
    "\002\023\004\000\002\023\005\000\002\024\005\000\002" +
    "\024\003\000\002\025\003\000\002\025\006\000\002\026" +
    "\005\000\002\026\003\000\002\036\003\000\002\036\003" +
    "\000\002\036\003\000\002\036\003\000\002\036\003\000" +
    "\002\036\003\000\002\027\005\000\002\027\003\000\002" +
    "\037\003\000\002\037\003\000\002\030\005\000\002\030" +
    "\003\000\002\040\003\000\002\040\003\000\002\031\005" +
    "\000\002\031\003\000\002\041\003\000\002\041\003\000" +
    "\002\032\005\000\002\032\003\000\002\032\003\000\002" +
    "\032\003\000\002\033\006\000\002\034\003\000\002\034" +
    "\003\000\002\035\005\000\002\035\003\000\002\043\002" +
    "" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\171\000\006\004\013\017\010\001\002\000\004\002" +
    "\173\001\002\000\010\002\ufffc\004\ufffc\017\ufffc\001\002" +
    "\000\010\002\ufffd\004\ufffd\017\ufffd\001\002\000\010\002" +
    "\000\004\013\017\010\001\002\000\004\043\ufff8\001\002" +
    "\000\004\043\014\001\002\000\010\002\ufffe\004\ufffe\017" +
    "\ufffe\001\002\000\004\043\ufff9\001\002\000\010\031\017" +
    "\032\015\035\016\001\002\000\034\002\ufffb\004\ufffb\013" +
    "\ufffb\015\ufffb\016\ufffb\017\ufffb\020\ufffb\031\ufffb\032\ufffb" +
    "\034\ufffb\036\ufffb\042\ufffb\043\ufffb\001\002\000\004\042" +
    "\167\001\002\000\006\004\013\017\021\001\002\000\006" +
    "\033\ufff6\040\165\001\002\000\006\033\ufff5\043\ufff8\001" +
    "\002\000\004\043\162\001\002\000\004\033\025\001\002" +
    "\000\006\033\ufff3\040\ufff3\001\002\000\004\034\026\001" +
    "\002\000\032\004\uffbb\013\uffbb\015\uffbb\016\uffbb\017\uffbb" +
    "\020\uffbb\031\uffbb\032\uffbb\034\uffbb\036\uffbb\042\uffbb\043" +
    "\uffbb\001\002\000\010\002\ufff7\004\ufff7\017\ufff7\001\002" +
    "\000\032\004\013\013\uffbb\015\uffbb\016\uffbb\017\010\020" +
    "\uffbb\031\uffbb\032\uffbb\034\uffbb\036\uffbb\042\uffbb\043\uffbb" +
    "\001\002\000\032\004\uffee\013\uffee\015\uffee\016\uffee\017" +
    "\uffee\020\uffee\031\uffee\032\uffee\034\uffee\036\uffee\042\uffee" +
    "\043\uffee\001\002\000\026\013\046\015\042\016\065\020" +
    "\043\031\062\032\055\034\026\036\037\042\050\043\047" +
    "\001\002\000\032\004\uffef\013\uffef\015\uffef\016\uffef\017" +
    "\uffef\020\uffef\031\uffef\032\uffef\034\uffef\036\uffef\042\uffef" +
    "\043\uffef\001\002\000\026\013\uffec\015\uffec\016\uffec\020" +
    "\uffec\031\uffec\032\uffec\034\uffec\036\uffec\042\uffec\043\uffec" +
    "\001\002\000\004\043\036\001\002\000\006\032\015\035" +
    "\016\001\002\000\036\002\ufff0\004\ufff0\013\ufff0\014\ufff0" +
    "\015\ufff0\016\ufff0\017\ufff0\020\ufff0\031\ufff0\032\ufff0\034" +
    "\ufff0\036\ufff0\042\ufff0\043\ufff0\001\002\000\030\013\uffe2" +
    "\014\uffe2\015\uffe2\016\uffe2\020\uffe2\031\uffe2\032\uffe2\034" +
    "\uffe2\036\uffe2\042\uffe2\043\uffe2\001\002\000\026\013\uffed" +
    "\015\uffed\016\uffed\020\uffed\031\uffed\032\uffed\034\uffed\036" +
    "\uffed\042\uffed\043\uffed\001\002\000\004\031\156\001\002" +
    "\000\012\031\062\032\154\042\050\043\047\001\002\000" +
    "\030\013\uffea\014\uffea\015\uffea\016\uffea\020\uffea\031\uffea" +
    "\032\uffea\034\uffea\036\uffea\042\uffea\043\uffea\001\002\000" +
    "\042\006\uffc7\007\uffc7\010\uffc7\011\uffc7\021\uffc7\022\uffc7" +
    "\023\uffc7\024\uffc7\025\uffc7\026\uffc7\027\uffc7\030\uffc7\032" +
    "\uffc7\033\uffc7\037\uffc7\040\uffc7\001\002\000\004\031\145" +
    "\001\002\000\050\006\uffda\007\uffda\010\uffda\011\uffda\012" +
    "\uffda\021\uffda\022\uffda\023\uffda\024\uffda\025\uffda\026\uffda" +
    "\027\uffda\030\uffda\031\133\032\uffda\033\uffda\035\132\037" +
    "\uffda\040\uffda\001\002\000\042\006\uffc1\007\uffc1\010\uffc1" +
    "\011\uffc1\021\uffc1\022\uffc1\023\uffc1\024\uffc1\025\uffc1\026" +
    "\uffc1\027\uffc1\030\uffc1\032\uffc1\033\uffc1\037\uffc1\040\uffc1" +
    "\001\002\000\004\032\131\001\002\000\030\013\uffe7\014" +
    "\uffe7\015\uffe7\016\uffe7\020\uffe7\031\uffe7\032\uffe7\034\uffe7" +
    "\036\uffe7\042\uffe7\043\uffe7\001\002\000\042\006\uffcb\007" +
    "\uffcb\010\uffcb\011\uffcb\021\112\022\113\023\uffcb\024\uffcb" +
    "\025\uffcb\026\uffcb\027\uffcb\030\uffcb\032\uffcb\033\uffcb\037" +
    "\uffcb\040\uffcb\001\002\000\032\006\122\007\117\023\116" +
    "\024\124\025\123\026\115\027\121\030\120\032\uffd7\033" +
    "\uffd7\037\uffd7\040\uffd7\001\002\000\030\013\uffe5\014\uffe5" +
    "\015\uffe5\016\uffe5\020\uffe5\031\uffe5\032\uffe5\034\uffe5\036" +
    "\uffe5\042\uffe5\043\uffe5\001\002\000\036\006\uffcf\007\uffcf" +
    "\010\106\011\104\023\uffcf\024\uffcf\025\uffcf\026\uffcf\027" +
    "\uffcf\030\uffcf\032\uffcf\033\uffcf\037\uffcf\040\uffcf\001\002" +
    "\000\012\032\uffdb\033\uffdb\037\uffdb\040\uffdb\001\002\000" +
    "\030\013\uffeb\014\uffeb\015\uffeb\016\uffeb\020\uffeb\031\uffeb" +
    "\032\uffeb\034\uffeb\036\uffeb\042\uffeb\043\uffeb\001\002\000" +
    "\030\013\uffe9\014\uffe9\015\uffe9\016\uffe9\020\uffe9\031\uffe9" +
    "\032\uffe9\034\uffe9\036\uffe9\042\uffe9\043\uffe9\001\002\000" +
    "\010\031\062\042\050\043\047\001\002\000\030\013\uffe8" +
    "\014\uffe8\015\uffe8\016\uffe8\020\uffe8\031\uffe8\032\uffe8\034" +
    "\uffe8\036\uffe8\042\uffe8\043\uffe8\001\002\000\030\013\uffe1" +
    "\014\uffe1\015\uffe1\016\uffe1\020\uffe1\031\uffe1\032\uffe1\034" +
    "\uffe1\036\uffe1\042\uffe1\043\uffe1\001\002\000\004\031\072" +
    "\001\002\000\042\006\uffc2\007\uffc2\010\uffc2\011\uffc2\021" +
    "\uffc2\022\uffc2\023\uffc2\024\uffc2\025\uffc2\026\uffc2\027\uffc2" +
    "\030\uffc2\032\uffc2\033\uffc2\037\uffc2\040\uffc2\001\002\000" +
    "\044\006\uffc3\007\uffc3\010\uffc3\011\uffc3\012\070\021\uffc3" +
    "\022\uffc3\023\uffc3\024\uffc3\025\uffc3\026\uffc3\027\uffc3\030" +
    "\uffc3\032\uffc3\033\uffc3\037\uffc3\040\uffc3\001\002\000\010" +
    "\031\062\042\050\043\047\001\002\000\012\032\uffdc\033" +
    "\uffdc\037\uffdc\040\uffdc\001\002\000\010\031\062\042\050" +
    "\043\047\001\002\000\004\040\074\001\002\000\010\031" +
    "\062\042\050\043\047\001\002\000\004\040\076\001\002" +
    "\000\010\031\062\042\050\043\047\001\002\000\004\033" +
    "\100\001\002\000\024\013\046\015\042\016\065\020\043" +
    "\031\062\032\055\034\026\042\050\043\047\001\002\000" +
    "\030\013\uffdf\014\uffdf\015\uffdf\016\uffdf\020\uffdf\031\uffdf" +
    "\032\uffdf\034\uffdf\036\uffdf\042\uffdf\043\uffdf\001\002\000" +
    "\004\033\103\001\002\000\042\006\uffc4\007\uffc4\010\uffc4" +
    "\011\uffc4\021\uffc4\022\uffc4\023\uffc4\024\uffc4\025\uffc4\026" +
    "\uffc4\027\uffc4\030\uffc4\032\uffc4\033\uffc4\037\uffc4\040\uffc4" +
    "\001\002\000\010\031\uffca\042\uffca\043\uffca\001\002\000" +
    "\010\031\062\042\050\043\047\001\002\000\010\031\uffc9" +
    "\042\uffc9\043\uffc9\001\002\000\042\006\uffc3\007\uffc3\010" +
    "\uffc3\011\uffc3\021\uffc3\022\uffc3\023\uffc3\024\uffc3\025\uffc3" +
    "\026\uffc3\027\uffc3\030\uffc3\032\uffc3\033\uffc3\037\uffc3\040" +
    "\uffc3\001\002\000\042\006\uffcc\007\uffcc\010\uffcc\011\uffcc" +
    "\021\112\022\113\023\uffcc\024\uffcc\025\uffcc\026\uffcc\027" +
    "\uffcc\030\uffcc\032\uffcc\033\uffcc\037\uffcc\040\uffcc\001\002" +
    "\000\010\031\062\042\050\043\047\001\002\000\010\031" +
    "\uffc6\042\uffc6\043\uffc6\001\002\000\010\031\uffc5\042\uffc5" +
    "\043\uffc5\001\002\000\042\006\uffc8\007\uffc8\010\uffc8\011" +
    "\uffc8\021\uffc8\022\uffc8\023\uffc8\024\uffc8\025\uffc8\026\uffc8" +
    "\027\uffc8\030\uffc8\032\uffc8\033\uffc8\037\uffc8\040\uffc8\001" +
    "\002\000\010\031\uffd3\042\uffd3\043\uffd3\001\002\000\010" +
    "\031\uffd5\042\uffd5\043\uffd5\001\002\000\010\031\uffcd\042" +
    "\uffcd\043\uffcd\001\002\000\010\031\uffd1\042\uffd1\043\uffd1" +
    "\001\002\000\010\031\uffd2\042\uffd2\043\uffd2\001\002\000" +
    "\010\031\uffce\042\uffce\043\uffce\001\002\000\010\031\uffd4" +
    "\042\uffd4\043\uffd4\001\002\000\010\031\uffd6\042\uffd6\043" +
    "\uffd6\001\002\000\010\031\062\042\050\043\047\001\002" +
    "\000\010\031\062\042\050\043\047\001\002\000\036\006" +
    "\uffd0\007\uffd0\010\106\011\104\023\uffd0\024\uffd0\025\uffd0" +
    "\026\uffd0\027\uffd0\030\uffd0\032\uffd0\033\uffd0\037\uffd0\040" +
    "\uffd0\001\002\000\016\006\122\007\117\032\uffd8\033\uffd8" +
    "\037\uffd8\040\uffd8\001\002\000\030\013\uffe6\014\uffe6\015" +
    "\uffe6\016\uffe6\020\uffe6\031\uffe6\032\uffe6\034\uffe6\036\uffe6" +
    "\042\uffe6\043\uffe6\001\002\000\010\031\062\042\050\043" +
    "\047\001\002\000\012\031\062\033\uffbb\042\050\043\047" +
    "\001\002\000\006\033\uffbf\040\141\001\002\000\004\033" +
    "\uffbe\001\002\000\006\033\uffbc\040\uffbc\001\002\000\004" +
    "\033\140\001\002\000\042\006\uffc0\007\uffc0\010\uffc0\011" +
    "\uffc0\021\uffc0\022\uffc0\023\uffc0\024\uffc0\025\uffc0\026\uffc0" +
    "\027\uffc0\030\uffc0\032\uffc0\033\uffc0\037\uffc0\040\uffc0\001" +
    "\002\000\010\031\062\042\050\043\047\001\002\000\006" +
    "\033\uffbd\040\uffbd\001\002\000\004\037\144\001\002\000" +
    "\044\006\uffd9\007\uffd9\010\uffd9\011\uffd9\012\uffd9\021\uffd9" +
    "\022\uffd9\023\uffd9\024\uffd9\025\uffd9\026\uffd9\027\uffd9\030" +
    "\uffd9\032\uffd9\033\uffd9\037\uffd9\040\uffd9\001\002\000\010" +
    "\031\062\042\050\043\047\001\002\000\004\033\147\001" +
    "\002\000\024\013\046\015\042\016\065\020\043\031\062" +
    "\032\055\034\026\042\050\043\047\001\002\000\030\013" +
    "\uffe4\014\151\015\uffe4\016\uffe4\020\uffe4\031\uffe4\032\uffe4" +
    "\034\uffe4\036\uffe4\042\uffe4\043\uffe4\001\002\000\024\013" +
    "\046\015\042\016\065\020\043\031\062\032\055\034\026" +
    "\042\050\043\047\001\002\000\030\013\uffe3\014\uffe3\015" +
    "\uffe3\016\uffe3\020\uffe3\031\uffe3\032\uffe3\034\uffe3\036\uffe3" +
    "\042\uffe3\043\uffe3\001\002\000\004\032\155\001\002\000" +
    "\030\013\uffde\014\uffde\015\uffde\016\uffde\020\uffde\031\uffde" +
    "\032\uffde\034\uffde\036\uffde\042\uffde\043\uffde\001\002\000" +
    "\030\013\uffdd\014\uffdd\015\uffdd\016\uffdd\020\uffdd\031\uffdd" +
    "\032\uffdd\034\uffdd\036\uffdd\042\uffdd\043\uffdd\001\002\000" +
    "\010\031\062\042\050\043\047\001\002\000\004\033\160" +
    "\001\002\000\024\013\046\015\042\016\065\020\043\031" +
    "\062\032\055\034\026\042\050\043\047\001\002\000\030" +
    "\013\uffe0\014\uffe0\015\uffe0\016\uffe0\020\uffe0\031\uffe0\032" +
    "\uffe0\034\uffe0\036\uffe0\042\uffe0\043\uffe0\001\002\000\010" +
    "\033\ufff2\035\163\040\ufff2\001\002\000\004\037\164\001" +
    "\002\000\006\033\ufff1\040\ufff1\001\002\000\006\004\013" +
    "\017\010\001\002\000\006\033\ufff4\040\ufff4\001\002\000" +
    "\004\037\170\001\002\000\004\032\171\001\002\000\034" +
    "\002\ufffa\004\ufffa\013\ufffa\015\ufffa\016\ufffa\017\ufffa\020" +
    "\ufffa\031\ufffa\032\ufffa\034\ufffa\036\ufffa\042\ufffa\043\ufffa" +
    "\001\002\000\010\002\uffff\004\uffff\017\uffff\001\002\000" +
    "\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\171\000\016\002\003\003\006\004\011\005\005\006" +
    "\004\042\010\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\012\004\171\005\005\006\004\042" +
    "\010\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\012\007\022\010\017\011\023" +
    "\042\021\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\012\026\001\001\000\006\013\027\043\030\001\001\000" +
    "\002\001\001\000\012\005\032\014\031\042\034\043\033" +
    "\001\001\000\002\001\001\000\042\012\043\015\040\016" +
    "\057\017\060\020\062\021\037\022\063\023\051\024\050" +
    "\025\066\026\056\027\053\030\055\031\052\032\044\033" +
    "\065\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\022\024\152" +
    "\025\066\026\056\027\053\030\055\031\052\032\044\033" +
    "\065\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\041\110\001\001\000\006" +
    "\036\124\037\125\001\001\000\002\001\001\000\004\040" +
    "\104\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\022\024\101\025\066\026\056\027\053\030" +
    "\055\031\052\032\044\033\065\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\022\024\070\025\066\026\056\027\053" +
    "\030\055\031\052\032\044\033\065\001\001\000\002\001" +
    "\001\000\022\024\072\025\066\026\056\027\053\030\055" +
    "\031\052\032\044\033\065\001\001\000\002\001\001\000" +
    "\022\024\074\025\066\026\056\027\053\030\055\031\052" +
    "\032\044\033\065\001\001\000\002\001\001\000\022\024" +
    "\076\025\066\026\056\027\053\030\055\031\052\032\044" +
    "\033\065\001\001\000\002\001\001\000\042\012\043\015" +
    "\100\016\057\017\060\020\062\021\037\022\063\023\051" +
    "\024\050\025\066\026\056\027\053\030\055\031\052\032" +
    "\044\033\065\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\025\106\031" +
    "\107\032\044\033\065\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\041\110\001\001\000\010\025\106\032" +
    "\113\033\065\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\016\025" +
    "\106\027\127\030\055\031\052\032\044\033\065\001\001" +
    "\000\014\025\106\030\126\031\052\032\044\033\065\001" +
    "\001\000\004\040\104\001\001\000\004\037\125\001\001" +
    "\000\002\001\001\000\022\024\142\025\066\026\056\027" +
    "\053\030\055\031\052\032\044\033\065\001\001\000\030" +
    "\024\135\025\066\026\056\027\053\030\055\031\052\032" +
    "\044\033\065\034\136\035\133\043\134\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\022\024\141\025\066\026\056" +
    "\027\053\030\055\031\052\032\044\033\065\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\022" +
    "\024\145\025\066\026\056\027\053\030\055\031\052\032" +
    "\044\033\065\001\001\000\002\001\001\000\042\012\043" +
    "\015\147\016\057\017\060\020\062\021\037\022\063\023" +
    "\051\024\050\025\066\026\056\027\053\030\055\031\052" +
    "\032\044\033\065\001\001\000\002\001\001\000\042\012" +
    "\043\015\151\016\057\017\060\020\062\021\037\022\063" +
    "\023\051\024\050\025\066\026\056\027\053\030\055\031" +
    "\052\032\044\033\065\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\022\024" +
    "\156\025\066\026\056\027\053\030\055\031\052\032\044" +
    "\033\065\001\001\000\002\001\001\000\042\012\043\015" +
    "\160\016\057\017\060\020\062\021\037\022\063\023\051" +
    "\024\050\025\066\026\056\027\053\030\055\031\052\032" +
    "\044\033\065\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\011\165\042" +
    "\021\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



    public AstNode raiz = null; //     Crea el nodo raiz en nulo.
    public String produc = ""; //Crea el string de las producciones a concatenar.
    public String tipoExpresion = ""; //String que guarda el tipo de una expresion
    public String getProduccion(){
     return this.produc;     
    }
	/* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" en la linea "+ (s.left+1));
                if (s.right >= 0)
                    m.append(", columna "+ (s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	//Hashtable table = new Hashtable();

  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // empty ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("empty",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // arg_list ::= expression 
            {
              AstNode RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode e = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "ARG_LIST::= EXPRESSION\n";
   		RESULT = e;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arg_list",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // arg_list ::= arg_list COMA expression 
            {
              AstNode RESULT =null;
		int alleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int alright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		AstNode al = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode e = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "ARG_LIST::= ARG_LIST COMA EXPRESSION\n";
   		RESULT = e;
   		e.setHermano(al);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("arg_list",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // args ::= empty 
            {
              AstNode RESULT =null;
		
   		this.parser.produc += "ARGS::= EMPTY\n";
   		RESULT = null;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("args",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // args ::= arg_list 
            {
              AstNode RESULT =null;
		int alleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int alright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode al = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "ARGS::= ARG_LIST\n";
   		RESULT = al;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("args",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // call ::= ID OPENBRACKET args CLOSEBRACKET 
            {
              AstNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AstNode a = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
   		this.parser.produc += "CALL::= ID OPENBRACKET ARGS CLOSEBRACKET\n";
   		RESULT = new AstExpFun(id,a,"expFun",idleft+1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("call",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // exp ::= NUM 
            {
              AstNode RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String n = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "EXP::= NUM\n";
         RESULT = new AstExpConst(n,"constante",nleft+1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // exp ::= call 
            {
              AstNode RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode c = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "EXP::= CALL\n";
   		RESULT = c;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // exp ::= var 
            {
              AstNode RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode v = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "EXP::= VAR\n";
   		RESULT = v;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // exp ::= OPENBRACKET expression CLOSEBRACKET 
            {
              AstNode RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AstNode e = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
   		this.parser.produc += "EXP::= OPENBRACKET EXPRESSION CLOSEBRACKET\n";
   		RESULT = e;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exp",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // powop ::= ROOT 
            {
              Integer RESULT =null;
		
   		this.parser.produc += "POWOP::= ROOT\n";
   		RESULT = sym.ROOT;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("powop",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // powop ::= POT 
            {
              Integer RESULT =null;
		
   		this.parser.produc += "POWOP::= POT\n";
   		RESULT = sym.POT;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("powop",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // factor ::= exp 
            {
              AstNode RESULT =null;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode ex = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "FACTOR::= EXP\n";
   		RESULT = ex;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // factor ::= factor powop exp 
            {
              AstNode RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		AstNode f = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Integer p = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode ex = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "FACTOR::= FACTOR POWOP EXP\n";
   		RESULT = ex;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // mulop ::= DIV 
            {
              Integer RESULT =null;
		
   		this.parser.produc += "MULOP::= DIV\n";
   		RESULT = sym.DIV;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // mulop ::= MULT 
            {
              Integer RESULT =null;
		
   		this.parser.produc += "MULOP::= MULT\n";
   		RESULT = sym.MULT;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // term ::= factor 
            {
              AstNode RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode f = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "TERM::= FACTOR\n";
   		RESULT = f;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("term",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // term ::= term mulop factor 
            {
              AstNode RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		AstNode t = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Integer m = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode f = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "TERM::= TERM MULOP FACTOR\n";
   		RESULT = new AstExpBin(m,t,f,"operador",tleft+1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("term",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // addop ::= SUBT 
            {
              Integer RESULT =null;
		
   		this.parser.produc += "ADDOP::= SUBT\n";
   		RESULT = sym.SUBT;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("addop",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // addop ::= ADD 
            {
              Integer RESULT =null;
		
   		this.parser.produc += "ADDOP::= ADD\n";
   		RESULT = sym.ADD;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("addop",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // additive_expression ::= term 
            {
              AstNode RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode t = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "ADDITIVE_EXPRESSION::= TERM\n";
   		RESULT = t;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("additive_expression",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // additive_expression ::= additive_expression addop term 
            {
              AstNode RESULT =null;
		int aeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		AstNode ae = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Integer a = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode t = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "ADDITIVE_EXPRESSION::= ADDITIVE_EXPRESSION ADDOP TERM\n";
   		RESULT = new AstExpBin(a,ae,t,"operador",tleft+1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("additive_expression",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // relop ::= NEQ 
            {
              Integer RESULT =null;
		
   		this.parser.produc += "RELOP::= NEQ\n";
   		RESULT = sym.NEQ;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // relop ::= EQ 
            {
              Integer RESULT =null;
		
   		this.parser.produc += "RELOP::= EQ\n";
   		RESULT = sym.EQ;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // relop ::= MAYEQ 
            {
              Integer RESULT =null;
		
   		this.parser.produc += "RELOP::= MAYEQ\n";
   		RESULT = sym.MAYEQ;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // relop ::= MAYOR 
            {
              Integer RESULT =null;
		
   		this.parser.produc += "RELOP::= MAYOR\n";
   		RESULT = sym.MAYOR;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // relop ::= MINOR 
            {
              Integer RESULT =null;
		
   		this.parser.produc += "RELOP::= MINOR\n";
   		RESULT = sym.MINOR;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // relop ::= MINEQ 
            {
              Integer RESULT =null;
		
   		this.parser.produc += "RELOP::= MINEQ\n";
   		RESULT = sym.MINEQ;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // simple_expression ::= additive_expression 
            {
              AstNode RESULT =null;
		int aeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aeright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode ae = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "SIMPLE_EXPRESION::= ADITIVE_EXPRESION\n";
   		RESULT = ae;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("simple_expression",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // simple_expression ::= additive_expression relop additive_expression 
            {
              AstNode RESULT =null;
		int ae1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ae1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		AstNode ae1 = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Integer r = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int ae2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ae2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode ae2 = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
         this.parser.produc += "SIMPLE_EXPRESION::= ADITIVE_EXPRESION RELOP ADITIVE_EXPRESION\n";
   		RESULT = new AstExpBin(r,ae1,ae2,"operador",ae1left+1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("simple_expression",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // var ::= ID OPENBRACKETCOR expression CLOSEBRACKETCOR 
            {
              AstNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AstNode e = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
   		this.parser.produc += "VAR::= ID OPENBRACKETCOR EXPRESSION CLOSEBRACKETCOR\n";
         RESULT = new AstExpVar(e,id,true,"expreVar",idleft+1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("var",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // var ::= ID 
            {
              AstNode RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
         this.parser.produc += "VAR::= ID\n";
   		RESULT = new AstExpVar(null,id,false,"expreVar",idleft+1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("var",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // expression ::= simple_expression 
            {
              AstNode RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode se = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "EXPRESSION::= SIMPLE_EXPRESSION\n";
   		RESULT = se;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // expression ::= var ASSIGN expression 
            {
              AstNode RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int vright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		AstNode v = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode e = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
         this.parser.produc += "EXPRESSION::= VAR ASSIGN EXPRESSION\n";
   		switch(this.parser.tipoExpresion){
                                case "expstmt":
                                RESULT = new AstExpAsign(v,e,sym.ASSIGN,"expstmt",vleft+1);
                                break;
                                default:
                                RESULT = new AstExpAsign(v,e,sym.ASSIGN,"expreAsig",vleft+1);
                                }
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // return_stmt ::= RETURN expression PUNTUACTION 
            {
              AstNode RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Symbol r = (Symbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AstNode e = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
   		this.parser.produc += "RETURN_STMT::= RETURN EXPRESSION PUNTUACTION\n";
   		RESULT = new AstReturnStmt(e,"retorno",rleft+1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("return_stmt",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // return_stmt ::= RETURN PUNTUACTION 
            {
              AstNode RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Symbol r = (Symbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
   		this.parser.produc += "RETURN_STMT::= RETURN PUNTUACTION\n";
   		RESULT = new AstReturnStmt(null,"retorno",rleft+1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("return_stmt",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // for_stmt ::= FOR OPENBRACKET expression COMA expression COMA expression CLOSEBRACKET statement 
            {
              AstNode RESULT =null;
		int obleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int obright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Symbol ob = (Symbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		AstNode e1 = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		AstNode e2 = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int e3left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e3right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		AstNode e3 = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode s = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "FOR_STMT::= FOR OPENBRACKET expression COMA expression COMA expression OPENBRACKETC STATEMENT\n";
   		RESULT = new AstIterStmt(e1,e2,e3,s,"selec",obleft+1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("for_stmt",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // while_stmt ::= WHILE OPENBRACKET expression CLOSEBRACKET statement 
            {
              AstNode RESULT =null;
		int obleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int obright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Symbol ob = (Symbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		AstNode e = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode s = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "WHILE_STMT::= WHILE OPENBRACKET EXPRESSION OPENBRACKETC STATEMENT\n";
   		RESULT = new AstIterStmt(e,s,false,"selec",obleft+1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("while_stmt",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // iteration_stmt ::= for_stmt 
            {
              AstNode RESULT =null;
		int fsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode fs = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                this.parser.produc += "iteration_stmt ::= for_stmt\n"; 
                RESULT = fs; 
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("iteration_stmt",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // iteration_stmt ::= while_stmt 
            {
              AstNode RESULT =null;
		int wsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int wsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode ws = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "ITERATION_STMT::= WHILE_STMT\n";
   		RESULT = ws;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("iteration_stmt",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // selection_stmt ::= IF OPENBRACKET expression CLOSEBRACKET statement ELSE statement 
            {
              AstNode RESULT =null;
		int obleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int obright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Symbol ob = (Symbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		AstNode e = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int s1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int s1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		AstNode s1 = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int s2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int s2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode s2 = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "SELECTION_STMT::= IF OPENBRACKET EXPRESSION CLOSEBRACKET STATEMENT ELSE STATEMENT\n";
   		RESULT = new AstSelectStmt(e,s1,s2,true,"selec",obleft+1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("selection_stmt",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // selection_stmt ::= IF OPENBRACKET expression CLOSEBRACKET statement 
            {
              AstNode RESULT =null;
		int obleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int obright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Symbol ob = (Symbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		AstNode e = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode s = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "SELECTION_STMT::= IF OPENBRACKET EXPRESSION CLOSEBRACKET STATEMENT\n";
   		RESULT = new AstSelectStmt(e,s,null,false,"selec",obleft+1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("selection_stmt",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // expression_stmt ::= PUNTUACTION 
            {
              AstNode RESULT =null;
		int pcleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pcright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Symbol pc = (Symbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "EXPRESSION_STMT::= PUNTUACTION\n";
   		RESULT = new AstVaciaStmt("vacio",pcleft+1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression_stmt",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // expression_stmt ::= expression PUNTUACTION 
            {
              AstNode RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AstNode e = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
         this.parser.tipoExpresion = "expstmt";
   		this.parser.produc += "EXPRESSION_STMT::= EXPRESSION PUNTUACTION\n";
   		RESULT = e;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression_stmt",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // statement ::= return_stmt 
            {
              AstNode RESULT =null;
		int rsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode rs = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "STATEMENT::= RETURN_STMT\n";
   		RESULT = rs;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // statement ::= iteration_stmt 
            {
              AstNode RESULT =null;
		int isleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int isright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode is = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "STATEMENT::= ITERATION_STMT\n";
   		RESULT = is;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // statement ::= selection_stmt 
            {
              AstNode RESULT =null;
		int ssleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ssright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode ss = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "STATEMENT::= SELECTION_STMT\n";
   		RESULT = ss;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // statement ::= compound_stmt 
            {
              AstNode RESULT =null;
		int csleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int csright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode cs = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "STATEMENT::= COMPOUND_STMT\n";
   		RESULT = cs;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // statement ::= expression_stmt 
            {
              AstNode RESULT =null;
		int esleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int esright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode es = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "STATEMENT::= EXPRESSION_STMT\n";
   		RESULT = es;
   
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // statement_list ::= empty 
            {
              AstNode RESULT =null;
		
   		this.parser.produc += "STATEMENT_LIST::= EMPTY\n";
   		RESULT = null; //Ya que en la terminal esta Empty.
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement_list",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // statement_list ::= statement_list statement 
            {
              AstNode RESULT =null;
		int slleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int slright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AstNode sl = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode s = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "STATEMENT_LIST::= STATEMENT_LIST STATEMENT\n";
   		RESULT = s;
   		s.setHermano(sl);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement_list",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // local_declarations ::= empty 
            {
              AstNode RESULT =null;
		
   		this.parser.produc += "LOCAL_DECLARATIONS::= EMPTY\n";
   		RESULT = null; //Ya que en la terminal esta Empty.
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("local_declarations",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // local_declarations ::= local_declarations var_declaration 
            {
              AstNode RESULT =null;
		int ldleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int ldright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AstNode ld = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int vdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int vdright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode vd = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "LOCAL_DECLARATIONS::= LOCAL_DECLARATIONS VAR_DECLARATION\n";
   		RESULT = vd;
   		vd.setHermano(ld);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("local_declarations",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // compound_stmt ::= OPENBRACKETLL local_declarations statement_list CLOSEBRACKETLL 
            {
              AstNode RESULT =null;
		int lileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int liright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Symbol li = (Symbol)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int ldleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ldright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		AstNode ld = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int slleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int slright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AstNode sl = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
   		this.parser.produc += "COMPOUND_STMT::= OPENBRACKETLL LOCAL_DECLARATIONS STATEMENT_LIST CLOSEBRACKETLL\n";
   		RESULT = new AstCompStmt(ld,sl, "compSt",lileft);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("compound_stmt",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // param ::= type_specifier ID OPENBRACKETCOR CLOSEBRACKETCOR 
            {
              AstNode RESULT =null;
		int tsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int tsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Integer ts = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
   		this.parser.produc += "PARAM::= TYPE_SPECIFIER ID OPENBRACKETCOR CLOSEBRACKETCOR \n";
   		RESULT = new AstParamDec(ts,id,true,"paramDecl",tsleft);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("param",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // param ::= type_specifier ID 
            {
              AstNode RESULT =null;
		int tsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Integer ts = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "PARAM::= TYPE_SPECIFIER ID \n";
   		RESULT = new AstParamDec(ts,id,false,"paramDecl",tsleft);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("param",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // param_list ::= param 
            {
              AstNode RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode p = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "PARAM_LIST::= PARAM \n";
   		RESULT = p;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("param_list",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // param_list ::= param_list COMA param 
            {
              AstNode RESULT =null;
		int plleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int plright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		AstNode pl = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode p = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "PARAM_LIST::= PARAM_LIST COMA PARAM \n";
   		RESULT = p;
   		p.setHermano(pl);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("param_list",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // params ::= VOID 
            {
              AstNode RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Symbol v = (Symbol)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "PARAMS::= VOID \n";
         RESULT = new AstParamDec(sym.VOID,null,false,"paramDecl",vleft);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("params",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // params ::= param_list 
            {
              AstNode RESULT =null;
		int plleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int plright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode pl = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "PARAMS::= PARAM_LIST \n";
   		RESULT = pl;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("params",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // fun_declaration ::= type_specifier ID OPENBRACKET params CLOSEBRACKET compound_stmt 
            {
              AstNode RESULT =null;
		int tsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int tsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Integer ts = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int paleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int paright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		AstNode pa = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int csleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int csright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode cs = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "FUN_DECLARATION::= TYPE_SPECIFIER ID OPENBRACKET PARAMS CLOSEBRACKET COMPOUND_STMT \n";
   		RESULT = new AstFunDec(ts,id,pa,cs,"funDecl",tsleft);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("fun_declaration",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // type_specifier ::= VOID 
            {
              Integer RESULT =null;
		
   		this.parser.produc += "TYPE_SPECIFIER::= VOID \n";
   		RESULT = sym.VOID;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_specifier",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // type_specifier ::= INT 
            {
              Integer RESULT =null;
		
   		this.parser.produc += "TYPE_SPECIFIER::= INT \n";
   		RESULT = sym.INT;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_specifier",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // var_declaration ::= type_specifier ID OPENBRACKETCOR NUM CLOSEBRACKETCOR PUNTUACTION 
            {
              AstNode RESULT =null;
		int tsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int tsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Integer ts = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int numleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String num = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
   		this.parser.produc += "VAR_DECLARATION::= TYPE_SPECIFIER ID OPENBRACKETCOR NUM CLOSEBRACKETCOR PUNTUACTION \n";
         RESULT = new AstVarDec(ts,id,num,"varDec",tsleft + 1);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("var_declaration",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // var_declaration ::= type_specifier ID PUNTUACTION 
            {
              AstNode RESULT =null;
		int tsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Integer ts = (Integer)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
   		this.parser.produc += "VAR_DECLARATION::= TYPE_SPECIFIER ID PUNTUACTION \n";
   		RESULT = new AstVarDec(ts,id,"varDec",tsleft + 1); //Identifica que no llega un corchete.
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("var_declaration",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // declaration ::= fun_declaration 
            {
              AstNode RESULT =null;
		int fdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fdright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode fd = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   		this.parser.produc += "DECLARATION::= FUN_DECLARATION \n";
   		RESULT = fd;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // declaration ::= var_declaration 
            {
              AstNode RESULT =null;
		int vdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int vdright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode vd = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
         this.parser.produc += "DECLARATION::= VAR_DECLARATION \n";
   		RESULT = vd;
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // declaration_list ::= declaration 
            {
              AstNode RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode d = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
    	this.parser.produc += "DECLARATION_LIST::= DECLARATION \n";
   		RESULT = d;
    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration_list",1, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // declaration_list ::= declaration_list declaration 
            {
              AstNode RESULT =null;
		int dlleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int dlright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AstNode dl = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode d = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
         this.parser.produc += "DECLARATION_LIST::= DECLARATION_LIST DECLARATION \n";
   		RESULT = d;
   		d.setHermano(dl);
   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("declaration_list",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // program ::= declaration_list 
            {
              AstNode RESULT =null;
		int dlleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dlright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		AstNode dl = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   		this.parser.raiz = new AstProgram("programa",dl,dlleft + 1);
   		this.parser.produc += "PROGRAM::= DECLARATION_LIST\n";
   		RESULT = this.parser.raiz;
    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		AstNode start_val = (AstNode)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

